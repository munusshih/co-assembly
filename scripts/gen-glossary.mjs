#!/usr/bin/env node
/**
 * gen-glossary.mjs
 *
 * Generates glossary MDX pages for ALL locales from the single source-of-truth:
 *   src/data/glossary.json
 *
 * Outputs:
 *   src/content/docs/meta/glossary.mdx          (ç¹é«”ä¸­æ–‡)
 *   src/content/docs/en/meta/glossary.mdx       (English)
 *
 * Run:
 *   node scripts/gen-glossary.mjs
 *
 * DO NOT manually edit the generated glossary.mdx files â€” edit glossary.json instead.
 */

import { readFileSync, writeFileSync, mkdirSync } from "fs";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, "..");
const GLOSSARY_JSON = resolve(ROOT, "src/data/glossary.json");

const glossary = JSON.parse(readFileSync(GLOSSARY_JSON, "utf-8"));

// â”€â”€â”€ Category labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CATEGORY_LABELS = {
  membership: { zh: "èº«åˆ†èˆ‡æˆå“¡", en: "Identity & Membership" },
  governance: { zh: "æ²»ç†æ©Ÿåˆ¶", en: "Governance" },
  finance: { zh: "è²¡å‹™åˆ¶åº¦", en: "Finance" },
  projects: { zh: "å°ˆæ¡ˆèˆ‡åˆä½œ", en: "Projects & Collaboration" },
  ip: { zh: "æ™ºæ…§è²¡ç”¢", en: "Intellectual Property" },
  culture: { zh: "çµ„ç¹”æ–‡åŒ–", en: "Organizational Culture" },
};

// Group by category, preserving declaration order
function groupByCategory(glossary) {
  const groups = {};
  for (const [id, entry] of Object.entries(glossary)) {
    const cat = entry.category || "other";
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push({ id, ...entry });
  }
  return groups;
}

// â”€â”€â”€ ZH generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateZH(groups) {
  const lines = [];
  lines.push(`---`);
  lines.push(`title: è©å½™è¡¨`);
  lines.push(`description: CoAssembly ç« ç¨‹ä¸­ä½¿ç”¨çš„å°ˆæœ‰åè©èˆ‡å®šç¾©`);
  lines.push(`---`);
  lines.push(``);
  lines.push(
    `{/* âš ï¸  æ­¤é é¢ç”± scripts/gen-glossary.mjs è‡ªå‹•ç”¢ç”Ÿï¼Œè«‹å‹¿æ‰‹å‹•ç·¨è¼¯ã€‚ */}`,
  );
  lines.push(
    `{/* è‹¥è¦ä¿®æ”¹è©å½™ï¼Œè«‹ç·¨è¼¯ src/data/glossary.jsonï¼Œç„¶å¾ŒåŸ·è¡Œ npm run gen:glossary */}`,
  );
  lines.push(``);
  lines.push(`æœ¬é åˆ—å‡º CoAssembly ç« ç¨‹ä¸­ä½¿ç”¨çš„å°ˆæœ‰åè©åŠå…¶å®šç¾©ã€‚`);
  lines.push(``);
  lines.push(`:::tip[ä½¿ç”¨æ–¹å¼]`);
  lines.push(`- é»æ“Šç« ç¨‹ä¸­çš„å°ˆæœ‰åè©é€£çµå³å¯æŸ¥çœ‹å®šç¾©`);
  lines.push(`- ä½¿ç”¨ <kbd>Ctrl/Cmd + F</kbd> å¿«é€Ÿæœå°‹æœ¬é `);
  lines.push(`- å¦‚è¦ä¿®æ”¹è©å½™ï¼Œè«‹ç·¨è¼¯ \`src/data/glossary.json\``);
  lines.push(`:::`);
  lines.push(``);

  for (const [cat, entries] of Object.entries(groups)) {
    const label = CATEGORY_LABELS[cat]?.zh || cat;
    lines.push(`---`);
    lines.push(``);
    lines.push(`## ${label}`);
    lines.push(``);

    for (const entry of entries) {
      lines.push(`### ${entry.zh} {#${entry.id}}`);
      lines.push(``);
      if (entry.en && entry.en !== entry.zh) {
        lines.push(`è‹±æ–‡ï¼š**${entry.en}**`);
        lines.push(``);
      }
      lines.push(entry.definition.zh);
      lines.push(``);
      if (entry.refs?.length) {
        const refLinks = entry.refs.map((ref) => {
          const bylaw = refToBylawPath(ref);
          return bylaw ? `[${ref}](${bylaw})` : ref;
        });
        lines.push(`ç›¸é—œæ¢æ–‡ï¼š${refLinks.join("ã€")}`);
        lines.push(``);
      }
    }
  }

  lines.push(`---`);
  lines.push(``);
  lines.push(`## ğŸ“ å»ºè­°æ–°å¢è¡“èª`);
  lines.push(``);
  lines.push(
    `å¦‚æœä½ ç™¼ç¾ç« ç¨‹ä¸­æœ‰æœªåˆ—å‡ºçš„é‡è¦è¡“èªï¼Œæ­¡è¿é€é [GitHub Issue](https://github.com/munusshih/co-assembly/issues) æˆ– PR æå‡ºå»ºè­°ï¼`,
  );
  lines.push(``);

  return lines.join("\n");
}

// â”€â”€â”€ EN generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateEN(groups) {
  const lines = [];
  lines.push(`---`);
  lines.push(`title: Glossary`);
  lines.push(
    `description: Technical terms and definitions used in the CoAssembly Bylaws`,
  );
  lines.push(`---`);
  lines.push(``);
  lines.push(
    `{/* âš ï¸  This page is auto-generated by scripts/gen-glossary.mjs â€” do not edit manually. */}`,
  );
  lines.push(
    `{/* To modify terms, edit src/data/glossary.json, then run: npm run gen:glossary */}`,
  );
  lines.push(``);
  lines.push(
    `This page lists the technical terms and their definitions used in the CoAssembly Bylaws.`,
  );
  lines.push(``);
  lines.push(`:::tip[How to use]`);
  lines.push(
    `- Click a term link in the bylaws to jump to its definition here`,
  );
  lines.push(`- Use <kbd>Ctrl/Cmd + F</kbd> to search this page`);
  lines.push(`- To modify terms, edit \`src/data/glossary.json\``);
  lines.push(`:::`);
  lines.push(``);

  for (const [cat, entries] of Object.entries(groups)) {
    const label = CATEGORY_LABELS[cat]?.en || cat;
    lines.push(`---`);
    lines.push(``);
    lines.push(`## ${label}`);
    lines.push(``);

    for (const entry of entries) {
      lines.push(`### ${entry.en} {#${entry.id}}`);
      lines.push(``);
      if (entry.zh && entry.zh !== entry.en) {
        lines.push(`Chinese: **${entry.zh}**`);
        lines.push(``);
      }
      lines.push(entry.definition.en);
      lines.push(``);
      if (entry.refs?.length) {
        const refLinks = entry.refs.map((ref) => {
          const bylaw = refToBylawPath(ref, true);
          return bylaw ? `[${ref}](${bylaw})` : ref;
        });
        lines.push(`Related articles: ${refLinks.join(", ")}`);
        lines.push(``);
      }
    }
  }

  lines.push(`---`);
  lines.push(``);
  lines.push(`## ğŸ“ Suggest a new term`);
  lines.push(``);
  lines.push(
    `Found an important term not listed? Open a [GitHub Issue](https://github.com/munusshih/co-assembly/issues) or submit a PR!`,
  );
  lines.push(``);

  return lines.join("\n");
}

// â”€â”€â”€ Helper: map article code (MEM-01) â†’ bylaw URL path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function refToBylawPath(ref, isEnglish = false) {
  const prefix = isEnglish ? "/en/bylaws/" : "/bylaws/";
  const map = {
    GEN: "01-general",
    MEM: "02-membership",
    GOV: "03-governance",
    FIN: "04-finance",
    PROJ: "05-projects-conflicts",
    PAY: "06-pay-distribution",
    POOL: "07-pool",
    IP: "08-ip-commons",
    DISC: "09-discipline-disputes",
    AMD: "10-amendments",
  };
  const match = ref.match(/^([A-Z]+)-/);
  if (!match) return null;
  const file = map[match[1]];
  if (!file) return null;
  const anchor = ref.toLowerCase().replace(/-(\d)$/, (_, n) => `-0${n}`);
  return `${prefix}${file}/#${ref.toLowerCase()}`;
}

// â”€â”€â”€ Write files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const groups = groupByCategory(glossary);

const zhOut = resolve(ROOT, "src/content/docs/meta/glossary.mdx");
const enOut = resolve(ROOT, "src/content/docs/en/meta/glossary.mdx");

mkdirSync(resolve(ROOT, "src/content/docs/meta"), { recursive: true });
mkdirSync(resolve(ROOT, "src/content/docs/en/meta"), { recursive: true });

writeFileSync(zhOut, generateZH(groups));
writeFileSync(enOut, generateEN(groups));

console.log("âœ… Generated:");
console.log(`   ${zhOut}`);
console.log(`   ${enOut}`);
